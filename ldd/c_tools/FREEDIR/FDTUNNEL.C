#include <stdlib.h>
#include <conio.h>
#include <math.h>

unsigned char  *screen = 0xA0000;


unsigned char  fdtexture[65536];
unsigned char  fdbuffer[64000];
unsigned char  fdlightmap[64000];

unsigned int   fdu[81 * 51], fdv[81 * 51], fdl[81 * 51];

unsigned char  fdpalxlat[65536];

         short sintab [65536];
         float sintabf[65536], costabf[65536];

typedef struct vec3f {
    float x, y, z;
} vec3f;

typedef struct vec2 {
    int x, y;
} vec2;

typedef struct mat4x4 {
    float a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p;
} mat4x4;

#define sat(a, l)  ((a > l) ? l : a)
#define sqr(a)     ((a)*(a))
#define sgn(a)     (((a) > 0) ? 1 : -1)

#define fdDIST     150
#define fdspr_size 16
#define fdcount    64
#define fdist_x    256
#define fdist_z    4096

#define ee         1.0E-6
#define bb         1.0E+4
#define pi         3.141592653589793

unsigned char fdspr[fdspr_size * fdspr_size];

vec3f fdp[fdcount], fdpt[fdcount];
vec2  fdp2d[fdcount];


void fdFillDots () {
    int i, lptr = 0;  
    
    for (i = 0; i < fdcount; i++) {
        fdp[lptr  ].x = (rand() % fdist_x) - (fdist_x >> 1);
        fdp[lptr  ].y = (rand() % fdist_x) - (fdist_x >> 1);
        fdp[lptr++].z = (rand() % fdist_x) - (fdist_x >> 1); 
    }
}


void fdMakeSprite() {
    int x, y, k;
    long sprptr = (long)&fdspr;
    
    for (y = -(fdspr_size >> 1); y < (fdspr_size >> 1); y++) {
        for (x = -(fdspr_size >> 1); x < (fdspr_size >> 1); x++) {
            *((char*)sprptr++) = sat((int)(0x80 / ((x*x + y*y) + ee)), 128) & 0xFF;
        }
    }
}

void fd3dMove (float ax, float ay, float az) {
    int i;
    
    for (i = 0; i < fdcount; i++) {
        fdpt[i].x += ax;
        fdpt[i].y += ay;
        fdpt[i].z += az;
    }
}

void fd3dProject() {
    int i;
    float t;
    for (i = 0; i < fdcount; i++) if (fdpt[i].z < 0) {
        t = fdDIST / (fdpt[i].z + ee);
        fdp2d[i].x = fdpt[i].x * t + 160;
        fdp2d[i].y = fdpt[i].y * t + 100;
    }
}

void fdDrawPoints () {
    int i, y, x, j;
    int px, py, ofs;
    long scrptr = (long)&fdbuffer;
    long sprptr = (long)&fdspr;
    
    for (i = 0; i < fdcount; i++) {
        sprptr = (long)&fdspr;
        px = fdp2d[i].x - (fdspr_size >> 1); py = fdp2d[i].y - (fdspr_size >> 1);
        
        if ((py<(200 - (fdspr_size)))&&(py>0)&&(px>0)&&(px<(312 - (fdspr_size)))&&(fdpt[i].z < 0)) {
            j = 0;
            scrptr = (long)&fdbuffer + ((py << 8) + (py << 6) + px);
            for (y = 0; y < (fdspr_size); y++) {
                for (x = 0; x < (fdspr_size); x++) {
                    *((char*)scrptr) = sat((*((char*)scrptr) + *((char*)sprptr)), 255);
                    scrptr++; sprptr++;
                }
                scrptr += (320 - (fdspr_size));
            }
        }
    }
}

void fdNormalize(vec3f *v) {
	float l = 1.0 / sqrt(v->x*v->x + v->y*v->y + v->z*v->z);

	v->x *= l;
	v->y *= l;
	v->z *= l;
}

void fdInterpolate() {
    typedef struct {int  sy0, sy1, sdy, ey0, ey1, edy, x0, x1, dx, sy, ey, sx;} _fd;
    
    int  x, y, i, j, k, gridptr = 0;
    long scrptr = (long)&fdbuffer;
    _fd u, v, l;
    
    for (j = 0; j < 50; j++) {
        for (i = 0; i < 80; i++) {
            
            u.sdy = (fdu[gridptr+81] - fdu[gridptr]) >> 2;
            u.sy  = (fdu[gridptr]);
            
            u.edy = (fdu[gridptr+82] - fdu[gridptr+1]) >> 2;
            u.ey  = (fdu[gridptr+1]);
            
            v.sdy = (fdv[gridptr+81] - fdv[gridptr]) >> 2;
            v.sy  = (fdv[gridptr]);
        
            v.edy = (fdv[gridptr+82] - fdv[gridptr+1]) >> 2;
            v.ey  = (fdv[gridptr+1]);
            
            l.sdy = (fdl[gridptr+81] - fdl[gridptr]) >> 2;
            l.sy  = (fdl[gridptr]);
        
            l.edy = (fdl[gridptr+82] - fdl[gridptr+1]) >> 2;
            l.ey  = (fdl[gridptr+1]);
            
            for (y = 0; y < 4; y++) {
                u.dx = (u.ey - u.sy) >> 2;
                u.sx = u.sy;
                
                v.dx = (v.ey - v.sy) >> 2;
                v.sx = v.sy;
                
                l.dx = (l.ey - l.sy) >> 2;
                l.sx = l.sy;
                
                for (x = 0; x < 4; x++) {
                    //*((char*)scrptr++) = (l.sx >> 8);
                    
                    //*((char*)scrptr++) = fdtexture[(((u.sx >> 8) & 0xFF) | (v.sx & 0xFF00))];
                    *((char*)scrptr++) = ((fdtexture[(((u.sx >> 8) & 0xFF) | (v.sx & 0xFF00))]) * l.sx) >> 16;
                    //u.sx += u.dx; v.sx += v.dx; l.sx += l.dx;
                }
                scrptr += (320 - 4);
                //u.sy += u.sdy; u.ey += u.edy; v.sy += v.sdy; v.ey += v.edy; l.sy += l.sdy; l.ey += l.edy;
            }
            gridptr++;
            scrptr -= (320 * 4) - 4;
        }
        gridptr++;
        scrptr += (320 * 3);
    } 
}

                //*((char*)sptr++) = (fdtexture[(((vx >> 8) & 0xFF) | (ux & 0xFF00))] * (tx >> 8)) >> 8;

void fdbuildSinTable() {
    int i, j;
    float r;
    
    for (i = 0; i < 65536; i++) {
        r = (sin(2 * pi * i / 65536));
        sintab[i] = 32767 * r;
        sintabf[i] = r;
        r = (cos(2 * pi * i / 65536));
        costabf[i] = r;
    }
}

void fd3dRotate (int ax, int ay, int az, vec3f *v) {
    // hehehe, this code is fully ported from my old freebasic demoz ;)
    int i;
    float sinx = sintabf[ax], cosx = costabf[ax];
    float siny = sintabf[ay], cosy = costabf[ay];
    float sinz = sintabf[az], cosz = costabf[az];
    float bx, by, bz, px, py, pz;  // temp var storage

        //pt[i] = p[i];
        
        py = v->y;
        pz = v->z;
        v->y = (py * cosx - pz * sinx);
        v->z = (py * sinx + pz * cosx);
        
        px = v->x;
        pz = v->z;
        v->x = (px * cosy - pz * siny);
        v->z = (px * siny + pz * cosy);
        
        px = v->x;
        py = v->y;
        v->x = (px * cosz - py * sinz);
        v->y = (px * sinz + py * cosz);

} 

void fdbuildTexture() {
    int x, y, i, k=0;
    
    
    for (y = 0; y < 256; y++) {
        for (x = 0; x < 256; x++) {
            //fdtexture[((y << 8) + x)] = sat((x ^ y), 255) & 0xFF;
            //texture[((y << 8) + x)] = (x ^ y) & 0xFF;
            fdtexture[((y << 8) + x)] = (x ^ y) | (rand() % 0x100) & 0xFF;
        }
    }
    
    /*
    for (i = 0; i < 2; i++)
    for (y = -128; y < 127; y++) {
        for (x = -128; x < 127; x++) {
            fdtexture[k++] = sat((int)(0x80000 / ((x*x | y*y) + ee)), 255) & 0xFF;
            //texture[((y << 8) + x)] = (x ^ y) & 0xFF;
            //ttexture[((y << 8) + x)] = (rand() % 0x100) & 0xFF;
        }
    }
    */
    
    // blur our texture
    for (k = 0; k < 1; k++)
    for (i = 0; i < 65536; i++) 
        fdtexture[i] = (fdtexture[(i-1)&0xFFFF] + fdtexture[(i+1)&0xFFFF] + 
                        fdtexture[(i-256)&0xFFFF] + fdtexture[(i+256)&0xFFFF]) >> 2; 
    
}

void fdBuildMatrix(mat4x4 *m, int rx, int ry, int rz) {
    float a, b, c, d, e, f;
    float ad, bd;
    
    a    = costabf[rx];
    b    = sintabf[rx];
    c    = costabf[ry];
    d    = sintabf[ry];
    e    = costabf[rz];
    f    = sintabf[rz];

    ad   =   a * d;
    bd   =   b * d;

    m->a =   c * e;
    m->b =  -c * f;
    m->c =  -d;
    m->e = -bd * e + a * f;
    m->f =  bd * f + a * e;
    m->g =  -b * c;
    m->i =  ad * e + b * f;
    m->j = -ad * f + b * e;
    m->k =   a * c;

    m->d =  m->h = m->l = m->m = m->n = m->o = 0;
    m->p =  1;
}

void fdMatrixMul4x4(mat4x4 *m, vec3f *v) {
    v->x = (m->a * v->x) + (m->b * v->y) + (m->c * v->z) + m->d;
    v->y = (m->e * v->x) + (m->f * v->y) + (m->g * v->z) + m->h;
    v->z = (m->i * v->x) + (m->j * v->y) + (m->k * v->z) + m->l;
}

void fdCalcPlanes(int ax, int ay, int az, int rx, int ry, int rz) {

    float FOV = (1.0f / 90);
    const TunnelSize = 144;
    
    int x, y, z, tptr = 0;
    unsigned int u, v;
    
    vec3f  origin, direction, intersect;
    mat4x4 rot;
    float t, l, fx, fy, delta, a, b, c, t1, t2;
    float tsq, _2a, _1pi, qx;

    // ASSUMING origin.y = 0!
    
    tsq = sqr(TunnelSize);
    _1pi = 1.0f / pi;
    
    //fdBuildMatrix(&rot, rx, ry, rz);

    origin.x = az;
    origin.y = 0;  
    origin.z = ax;
    
    qx = sqr(origin.x);
    
    for (y = 0; y < 51; y++) {
        for (x = 0; x < 81; x++) {
            
            direction.x = (float)((x * 4) - 160 /*+ (16 * sintabf[((x << 11) + (ax << 5)) & 0xFFFF])*/) * FOV;
            direction.z = 1;
            direction.y = (float)((y * 4) - 100 /*+ (16 * costabf[((y << 11) + (ax << 5)) & 0xFFFF])*/) * FOV;
            
            
            fdNormalize(&direction);
            fd3dRotate(rx, ry, rz, &direction);
            //fdMatrixMul4x4(&rot, &direction);
            
            a = (sqr(direction.x) + sqr(direction.y));
            b = 2 * (origin.x * direction.x);
            c = (qx - tsq);

            delta = sqrt(b * b - 4 * a * c);
            _2a   = 1.0f / (2 * a + ee);
            
            t1 = (-b + delta) * _2a;
            t2 = (-b - delta) * _2a;

            t = t1 > 0 ? t1 : t2;
            
            intersect.x = origin.x + (direction.x * t);
            intersect.y = (direction.y * t);
            intersect.z = origin.z + (direction.z * t);
            
            u = (unsigned int)((intersect.z * 256) * _1pi);
            v = (unsigned int)((fabs(atan2(intersect.y, intersect.x)) * 65536 * _1pi));
            
            fdu[tptr] = u;// & 0xFFFFFF00;
            fdv[tptr] = v;// & 0xFFFFFF00;
            
            
            if (t > bb) {
                fdu [tptr] = 0;
                fdv [tptr] = 0;
                fdl [tptr] = 0;
            } else { 
                t = (TunnelSize * 128) / t;
                z = sat(t, 255);
                fdl[tptr] = (z << 8); 
            }
            
            tptr++;
        }
    }
}

int main() {
    int i, j, p = 0;
    
    fdbuildSinTable();
    fdbuildTexture();
    fdFillDots();
    fdMakeSprite();
    
    _asm {
        mov  ax, 13h
        int  10h
    } 
    _asm {    
        // zpizzheno ;)
        mov ax,13h
        int 10h       // regular mode 13h chained

        mov dx,3d4h   // remove protection
        mov al,11h
        out dx,al
        inc dl
        in  al,dx
        and al,7fh
        out dx,al

        mov dx,3c2h   // misc output
        mov al,0e3h   // clock
        out dx,al

        mov dx,3d4h
        mov ax,00B06h // Vertical Total
        out dx,ax
        mov ax,03E07h // Overflow
        out dx,ax
        mov ax,0C310h // Vertical start retrace
        out dx,ax
        mov ax,08C11h // Vertical end retrace
        out dx,ax
        mov ax,08F12h // Vertical display enable end
        out dx,ax
        mov ax,09015h // Vertical blank start
        out dx,ax
        mov ax,00B16h // Vertical blank end
        out dx,ax
    }
    
    outp(0x3C8, 0);
    for (i = 0; i < 256; i++) {
        
        outp(0x3C9, sat(((i >> 3) + (i >> 4)), 63));
        outp(0x3C9, sat(((i >> 3) + (i >> 3)), 63));
        outp(0x3C9, sat(((i >> 3) + (i >> 3) + (i >> 4)), 63)); 
        
        /*
        outp(0x3C9, sat((i >> 2), 63));
        outp(0x3C9, sat((i >> 2), 63)); 
        outp(0x3C9, sat((i >> 2), 63));
        */    
    }
    for (j = 0; j < 256; j++) for (i = 0; i < 256; i++) fdpalxlat[p++] = (i * j) >> 8;
    
    while (!kbhit()) {
        i++;
        
        while ((inp(0x3DA) & 8) == 8) {}
        while ((inp(0x3DA) & 8) != 8) {}

        outp(0x3C8, 0); outp(0x3C9, 63); outp(0x3C9, 0); outp(0x3C9, 0);
        
        memcpy(screen, &fdbuffer, 64000);

        fdCalcPlanes((i << 3), 0, (sintab[((i << 8) + (i << 7)) & 0xFFFF]) >> 8, 
                    ((i << 6) & 0xFFFF), ((i << 7) & 0xFFFF), ((i << 8) & 0xFFFF));
        //fdCalcPlanes((i << 0), 0, 128,
        //            ((i << 4) & 0xFFFF), ((i << 4) & 0xFFFF), ((i << 5) & 0xFFFF));        

        outp(0x3C8, 0); outp(0x3C9, 63); outp(0x3C9, 63); outp(0x3C9, 0);
        
        fdInterpolate();
        outp(0x3C8, 0); outp(0x3C9, 63); outp(0x3C9, 0); outp(0x3C9, 63);
        
        /*
        for (j = 0; j < (fdcount); j++) {
            fdpt[j] = fdp[j];
            fd3dRotate(((i << 6) & 0xFFFF), ((i << 7) & 0xFFFF), ((i << 8) & 0xFFFF), &fdpt[j]);
        }
        fd3dMove(0, 0, 0);
        fd3dProject();
        fdDrawPoints();
        */
        
        outp(0x3C8, 0); outp(0x3C9, 0); outp(0x3C9, 63); outp(0x3C9, 0); 
    }
    getch();
    
    _asm {
        mov  ax, 3
        int  10h
    }
}
